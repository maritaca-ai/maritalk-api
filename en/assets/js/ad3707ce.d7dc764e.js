"use strict";(self.webpackChunkmaritaca=self.webpackChunkmaritaca||[]).push([[4861],{8747:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=t(4848),a=t(8453);const r={id:"structured-outputs",title:"Structured Outputs"},i="Structured Outputs",o={id:"en/structured-outputs",title:"Structured Outputs",description:"Structured Outputs ensure that the data generated by models adheres to predefined user-provided schemas, such as JSON, simplifying integrations into applications. When the response format is critical, strategies like regular expressions (regex) can be employed, but these approaches are often fragile, complex, and unable to guarantee that all fields are extracted accurately and consistently. On the other hand, Structured Outputs offer a more reliable solution, reducing errors and facilitating direct integration. However, in cases where narrative responses or flexibility are a priority, their use is not necessary.",source:"@site/docs/en/structured_outputs.md",sourceDirName:"en",slug:"/en/structured-outputs",permalink:"/en/en/structured-outputs",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"structured-outputs",title:"Structured Outputs"},sidebar:"sidebarEn",previous:{title:"Function Calls",permalink:"/en/en/function-call"},next:{title:"Embeddings+Sabia-3+RAG",permalink:"/en/en/embeddings+Sabia-3+RAG"}},l={},c=[{value:"Use Cases Examples",id:"use-cases-examples",level:2},{value:"1. Data Extraction",id:"1-data-extraction",level:3},{value:"2. Sentiment Analysis",id:"2-sentiment-analysis",level:3},{value:"3. Reading Plan",id:"3-reading-plan",level:3},{value:"4. Usage with Stream",id:"4-usage-with-stream",level:3},{value:"How to Use the response_format Parameter",id:"how-to-use-the-response_format-parameter",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Supported Schemas",id:"supported-schemas",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"structured-outputs",children:"Structured Outputs"})}),"\n",(0,s.jsx)(n.p,{children:"Structured Outputs ensure that the data generated by models adheres to predefined user-provided schemas, such as JSON, simplifying integrations into applications. When the response format is critical, strategies like regular expressions (regex) can be employed, but these approaches are often fragile, complex, and unable to guarantee that all fields are extracted accurately and consistently. On the other hand, Structured Outputs offer a more reliable solution, reducing errors and facilitating direct integration. However, in cases where narrative responses or flexibility are a priority, their use is not necessary."}),"\n",(0,s.jsx)(n.h2,{id:"use-cases-examples",children:"Use Cases Examples"}),"\n",(0,s.jsx)(n.h3,{id:"1-data-extraction",children:"1. Data Extraction"}),"\n",(0,s.jsx)(n.p,{children:"Extract structured information from unstructured text:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from pydantic import BaseModel\nimport openai\n\nclient = openai.OpenAI(\n    api_key="", #Your API_KEY\n    base_url="https://chat.maritaca.ai/api",\n)\n\nclass EventDetails(BaseModel):\n    event_name: str\n    date: str\n    participants: list[str]\n    attire: list[str]\n\ncompletion = client.beta.chat.completions.parse(\n    model="sabia-3",\n    messages=[\n        {"role": "system", "content": "Extract event details."},\n        {"role": "user", "content": "Jo\xe3o and Maria are going to a June festival on Saturday at 6 PM in Campina Grande. They will be dressed for the occasion: Maria in a floral dress and Jo\xe3o in a plaid shirt and straw hat."}\n    ],\n    response_format=EventDetails,\n)\n\nevent_response = completion.choices[0].message.parsed\n\nprint(event_response)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-sentiment-analysis",children:"2. Sentiment Analysis"}),"\n",(0,s.jsx)(n.p,{children:"Identify sentiments in texts:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import openai\n\nclient = openai.OpenAI(\n    api_key="", #Your API_KEY\n    base_url="https://chat.maritaca.ai/api",\n)\n\nsentiment_schema = {\n    "type": "object",\n    "schema": {\n        "properties": {\n            "text": {"type": "string"},\n            "sentiment": {"type": "string", "enum": ["positive", "negative", "neutral"]},\n        },\n        "required": ["text", "sentiment"],\n    }\n}\n\ncompletion = client.beta.chat.completions.parse(\n    model="sabia-3",\n    messages=[\n        {"role": "system", "content": "Classify the sentiment of the text as positive, negative, or neutral."},\n        {"role": "user", "content": "I hated the job offered!"},\n    ],\n    response_format={"type": "json_schema", "json_schema": sentiment_schema}\n)\n\nresult = completion.choices[0].message.content\nprint(result)\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-reading-plan",children:"3. Reading Plan"}),"\n",(0,s.jsx)(n.p,{children:"Generate a structured reading plan based on the user's request, validating the data with a JSON schema and displaying the books with their details."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from enum import Enum\nfrom typing import List, Optional\nfrom pydantic import BaseModel\nimport openai\nimport json\n\nclient = openai.OpenAI(\n    api_key="",  #Your API_KEY\n    base_url="https://chat.maritaca.ai/api",\n)\n\nclass ReadingType(str, Enum):\n    classic = "classic"\n    contemporary = "contemporary"\n\nclass Book(BaseModel):\n    type: ReadingType\n    title: str\n    author: str\n    description: str\n\nBook.model_rebuild()\n\nclass ReadingPlan(BaseModel):\n    plan_name: str\n    books: List[Book]\n\n\nschema = {\n    "type": "object",\n    "schema": {\n        "properties": {\n            "plan_name": {"type": "string"},\n            "books": {\n                "type": "array",\n                "items": {\n                    "type": "object",\n                    "properties": {\n                        "type": {"type": "string", "enum": ["classic", "contemporary"]},\n                        "title": {"type": "string"},\n                        "author": {"type": "string"},\n                        "description": {"type": "string"},\n                        "subitems": {"type": ["array", "null"]}\n                    },\n                    "required": ["type", "title", "author", "description"]\n                }\n            }\n        },\n        "required": ["plan_name", "books"]\n    }\n}\n\ncompletion = client.beta.chat.completions.parse(\n    model="sabia-3",\n    messages=[\n        {"role": "system", "content": "You are a reading plan generator. Convert the user\'s request into a structured reading plan."},\n        {"role": "user", "content": "Create a reading plan to explore Brazilian literature, including classics and contemporary works."}\n    ],\n    response_format={"type": "json_schema", "json_schema": schema}\n)\n\nreading_plan = ReadingPlan.model_validate(json.loads(completion.choices[0].message.content))\n\nprint("Plan Name:", reading_plan.plan_name)\nprint("Books:")\nfor book in reading_plan.books:\n    print(f" - {book.title} by {book.author}: {book.description}")\n\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-usage-with-stream",children:"4. Usage with Stream"}),"\n",(0,s.jsx)(n.p,{children:"In the case of stream usage, structured outputs can be processed in real time as they are generated, providing a more interactive experience. This method is particularly advantageous for handling tasks involving the generation of large volumes of data or extensive responses. Below, we present an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from typing import List, Dict\nfrom pydantic import BaseModel\nimport openai\n\nclass TypicalDishesModel(BaseModel):\n    dishes: List[str]\n\nclient = openai.OpenAI(\n    api_key="",  #Your API_KEY\n    base_url="https://chat.maritaca.ai/api",\n)\n\nwith client.beta.chat.completions.stream(\n    model="sabia-3",\n    messages=[\n        {"role": "system", "content": "Identify the typical Brazilian dishes in the provided text."},\n        {\n            "role": "user",\n            "content": "At the June festival, we have canjica, pamonha, curau, and quent\xe3o, along with lots of music and dancing.",\n        },\n    ],\n    response_format=TypicalDishesModel,\n) as stream:\n    for event in stream:\n        if event.type == "content.delta":\n            if event.parsed is not None:\n                print("content.delta parsed:", event.parsed)\n        elif event.type == "content.done":\n            print("content.done")\n        elif event.type == "error":\n            print("Error in stream:", event.error)\n\nfinal_completion = stream.get_final_completion()\nprint("Final completion:", final_completion)\n\n\n'})}),"\n",(0,s.jsx)(n.h2,{id:"how-to-use-the-response_format-parameter",children:"How to Use the response_format Parameter"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"response_format"})," parameter is used to instruct the model to generate responses that follow a predefined structured format. The values for response_format are:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"JSON Schema (json_schema): Define a JSON schema to validate the structure and data types of the response."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'response_format={type: "json_schema", json_schema: {"strict": true, "schema": ...}}\nor\nresponse_format={type: "json_schema", schema: {...}}\n\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Pydantic Models: Use Pydantic classes to map and validate the returned data."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"response_format=ModelPydantic\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Simple JSON Object: Also known as json mode, where a JSON object is requested without additional validations:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'response_format={"type": "json_object"}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Define Clear Schemas: Use tools like JSON Schema or Pydantic to design appropriate schemas."}),"\n",(0,s.jsx)(n.li,{children:"Validate Input: Ensure that user inputs are compatible with the schema."}),"\n",(0,s.jsx)(n.li,{children:"Error Handling: Include logic to handle refusals or malformed responses programmatically."}),"\n"]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)("div",{className:"custom-box",style:{display:"flex",alignItems:"center",backgroundColor:"#B0E0E6",padding:"10px",border:"1px solid #B0E0E6",borderRadius:"5px",margin:"10px 0",color:"black"},children:[(0,s.jsx)("span",{style:{fontSize:"1.5em",marginRight:"10px",color:"#B0E0E6"},children:"\ud83d\udca1"}),(0,s.jsxs)("div",{children:[(0,s.jsx)("strong",{style:{display:"block",fontSize:"1em",marginBottom:"5px"},children:" JSON MODE "}),(0,s.jsx)("p",{style:{fontSize:"0.9em"},children:" The JSON mode only ensures that the model's output is valid JSON. Structured Outputs, on the other hand, reliably match the model's output to the schema you specify. We recommend using Structured Outputs if it is supported for your use case. When using JSON mode, if the instruction to produce a JSON object is not explicitly passed to the model, it may generate an endless stream of whitespace, and the request could run continuously until it reaches the token limit."})]})]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.h2,{id:"supported-schemas",children:"Supported Schemas"}),"\n",(0,s.jsx)(n.p,{children:"Structured Outputs is compatible with a subset of JSON Schema, allowing you to use the following types: String, Number, Boolean, Integer, Object, Array, Enum, anyOf, and oneOf. To maintain stability and proper functionality, some JSON Schema features are not supported \u2014 for example: minLength, maxLength, pattern, format, minimum, maximum, multipleOf, minItems, maxItems, uniqueItems, minProperties, maxProperties, allOf, patternProperties, unevaluatedProperties, propertyNames, unevaluatedItems, and contains."}),"\n",(0,s.jsx)(n.p,{children:"When working with objects, you can use up to 100 properties, with a maximum of 5 levels of nesting. To optimize your schema\u2019s structure, the total length of all property names, definitions, enum values, and const values must remain below 15,000 characters. For enum fields, you can include up to 500 values in total. However, if a single enum exceeds 250 values (all of type string), the total length of those values must stay below 7,500 characters. If any limit is exceeded or if any unsupported feature is encountered, an error will be generated."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);